<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:int="http://www.springframework.org/schema/integration"
	xmlns:int-stream="http://www.springframework.org/schema/integration/stream"
	xmlns:int-event="http://www.springframework.org/schema/integration/event"
	xmlns:int-http="http://www.springframework.org/schema/integration/http"
	xmlns:int-ws="http://www.springframework.org/schema/integration/ws"
	xmlns:task="http://www.springframework.org/schema/task"
	xmlns:int-mongodb="http://www.springframework.org/schema/integration/mongodb"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/oxm http://www.springframework.org/schema/oxm/spring-oxm.xsd
		http://www.springframework.org/schema/integration/stream http://www.springframework.org/schema/integration/stream/spring-integration-stream-4.3.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
		http://www.springframework.org/schema/integration/event http://www.springframework.org/schema/integration/event/spring-integration-event.xsd
		http://www.springframework.org/schema/integration/http http://www.springframework.org/schema/integration/http/spring-integration-http-4.3.xsd
		http://www.springframework.org/schema/integration/mail http://www.springframework.org/schema/integration/mail/spring-integration-mail.xsd
		http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration-4.3.xsd
		http://www.springframework.org/schema/integration/ws http://www.springframework.org/schema/integration/ws/spring-integration-ws.xsd
		http://www.springframework.org/schema/task http://www.springframework.org/task/spring-task.xsd
		http://www.springframework.org/schema/integration/mongodb http://www.springframework.org/schema/integration/mongodb/spring-integration-mongodb.xsd
		http://www.springframework.org/schema/util		http://www.springframework.org/schema/util/spring-util.xsd">


	<context:component-scan base-package="org.cg.ads" />

	<task:executor id="executor" pool-size="5" />

	<bean id="serverStartupListener" class="org.cg.ads.integration.ServerStartupListener" />
	<bean id="siteScraperFactory" class="org.cg.scraping.SiteScraperFactory" />
	<bean id="logActivator" class="org.cg.ads.integration.LogActivator" />
	<bean id="spelBridge" class="org.cg.ads.integration.SpelBridge" />
	<bean id="nullChannel" class="org.springframework.integration.channel.NullChannel" />

	<!-- that's the way to access enviromnemt variables -->
	<!-- but not the way to delay the pingback, seems the receiving thread is 
		gone when the message finally gets delivered -->
	<!-- <int:delayer id="delayer" input-channel="pingBackChannel" output-channel="do_pingBackChannel" 
		default-delay="3000" expression="@configurationProperties['ads.httpTimeout']" 
		/> -->


	<bean id="appProperties"
		class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
		<property name="location" value="classpath:application.properties" />
	</bean>

	<int:service-activator input-channel="pingBackChannel">
		<description>returns the received message as is to the replyChannel in
			the message header, given there is one. the message gets delayed
			until the common http timeout, but still it could be that a 0
			priority message arrives before others. say, until the 0 priority
			message's timeout only other massages get processed that time out
			too, but later on some succeed
		</description>
		<bean class="org.cg.ads.integration.PingBackMassageHandler">
			<constructor-arg index="0" value="${ads.httpTimeout}" />
		</bean>

	</int:service-activator>

	<int:recipient-list-router input-channel="getPageForUrlChannelPriorityFiltered">
		<int:recipient channel="pingBackChannel"
			selector-expression="headers[priority] == 0" />
		<int:recipient channel="getPageForUrlChannel"
			selector-expression="headers[priority] > 0" />
	</int:recipient-list-router>

	<int-http:outbound-gateway id="html" url="{url}"
		request-channel="getPageForUrlChannel" http-method="GET"
		expected-response-type="java.lang.String" charset="UTF-8"
		reply-timeout="${ads.httpTimeout}">
		<int-http:uri-variable name="url" expression="payload" />
	</int-http:outbound-gateway>


	<!-- *** system entry *** -->
	<int:gateway default-request-channel="systemEntry"
		service-interface="org.cg.ads.SystemEntryGateway" />

	<int:chain id="waitToStartupFinishedAndSplit" input-channel="systemEntry"
		output-channel="systemEntryAfterStartup">
		<int:filter ref="serverStartupListener" discard-channel="logPrematureMessages" />
		<int:splitter expression="payload" />
		<int:header-enricher>
			<int:header name="_split1" expression="'split # 1'" />
			<int:priority expression="payload.toString().contains('sentinel') ? 0 : 1" />
		</int:header-enricher>
	</int:chain>

	<int:channel id="systemEntryAfterStartup">
		<int:dispatcher task-executor="executor" />
	</int:channel>

	<int:chain id="scrapeMasterList" input-channel="systemEntryAfterStartup"
		output-channel="scrapeMasterListResultChannel">

		<int:header-enricher>
			<int:header name="urlId" expression="payload.id" />
			<int:header name="baseUrl" expression="payload.url" />
		</int:header-enricher>

		<int:service-activator ref="logActivator"
			method="logMessage" />


		<!-- actually there's no need to enrich/transform with id and url in header, 
			but it makes reuse of http gateway possible -->

		<int:transformer id="packPayloadForEnrichmentByAdMainPageHttpRequest"
			expression="new org.cg.ads.integration.PayloadEnrichmentTarget(payload)" />
		<int:enricher id="getPageForUrlEnricher" request-channel="getPageForUrlChannelPriorityFiltered"
			error-channel="httpErrorChannel" request-payload-expression="headers['baseUrl']">
			<int:property name="added" expression="payload" />
		</int:enricher>

		<!-- (String, String) -> List<ScrapedValues> -->
		<int:transformer
			expression="@spelBridge.scrapeMasterList(headers['baseUrl'], payload.added)" />

		<int:splitter expression="payload" />

		<int:header-enricher>
			<int:header name="_split2" expression="'split # 2'" />
			<int:header name="detailUrl"
				expression="payload.has(T(org.cg.ads.advalues.ValueKind).url) ? payload.valueOrDefault(T(org.cg.ads.advalues.ValueKind).url) : '' " />
		</int:header-enricher>

	</int:chain>

	<int:channel id="scrapeMasterListResultChannel">
		<int:dispatcher task-executor="executor" />
	</int:channel>

	<int:chain id="scrapeDetails" input-channel="scrapeMasterListResultChannel"
		output-channel="scrapeResultChannel">

		<int:header-enricher>
			<int:header name="detailUrl"
				expression="payload.has(T(org.cg.ads.advalues.ValueKind).url) ? payload.valueOrDefault(T(org.cg.ads.advalues.ValueKind).url) : '' " />
		</int:header-enricher>

		<int:service-activator ref="logActivator"
			method="logMessage" />

		<int:filter id="filterForDetailUrlPresent"
			expression="headers['priority'] == 0 or ! headers['detailUrl'].equals('')" />

		<int:filter id="filterForUrlsNotYetScraped"
			expression="headers['priority'] == 0 or ! T(org.cg.history.History).instance().find(headers['urlId'], headers['detailUrl'])" />

		<int:transformer id="packPayloadForEnrichmentByAdDetailPageHttpRequest"
			expression="new org.cg.ads.integration.PayloadEnrichmentTarget(payload)" />

		<int:enricher id="getPageForDetailUrl" request-channel="getPageForUrlChannelPriorityFiltered"
			error-channel="httpErrorChannel" request-payload-expression="headers['detailUrl']">
			<int:property name="added" expression="payload" />
		</int:enricher>

		<!-- (ScrapedValues, String) -> ScrapedValues (with more properties) -->
		<int:transformer
			expression="@spelBridge.scrapeDetails(headers['detailUrl'], payload.base, payload.added)" />

	</int:chain>

	<int:recipient-list-router input-channel="scrapeResultChannel"
		ignore-send-failures="true">
		<int:recipient channel="scrapeResultSyncChannel" />
		<int:recipient channel="removeSentinelsChannel" />
		<!--int:recipient channel="aggretationChannel" / -->
	</int:recipient-list-router>

	<int:publish-subscribe-channel id="scrapeResultChannel"
		ignore-failures="true" />

	<int:channel id="scrapeResultSyncChannel">
		<int:priority-queue capacity="200" />
	</int:channel>

	<int:chain input-channel="scrapeResultSyncChannel">
		<int:poller receive-timeout="500" fixed-rate="10000" /> <!-- each poll may run in different thread -->
		<int:transformer
			expression="'result - thread '.concat(T(Thread).currentThread().id).concat(' ') + payload.toString()" />
		<int-stream:stdout-channel-adapter
			id="consoleOut" append-newline="true" />
	</int:chain>

	<int:filter id="removeSentinels" expression="headers['priority'] > 0"
		input-channel="removeSentinelsChannel" output-channel="desentinalizedscrapeResultChannel" />

	<int:publish-subscribe-channel id="desentinalizedscrapeResultChannel"
		ignore-failures="true" />

	<int:transformer input-channel="httpErrorChannel"
		output-channel="logChannel" expression="'httpError:' + payload.toString()" />

	<int:transformer input-channel="invalidAdsChannel"
		output-channel="logChannel" expression="'discarded invalid ad: '.concat(headers['detailUrl'])" />

	<int:transformer input-channel="logPrematureMessages"
		output-channel="logChannel"
		expression="'didnt wait for server to start, discarded: ' + payload.toString()" />

	<int:chain input-channel="desentinalizedscrapeResultChannel"
		output-channel="nullChannel">

		<int:service-activator id="storeInHistory" ref="spelBridge"
			method="historyStorage" />
	</int:chain>

	<int:chain input-channel="scrapeResultChannel"
		output-channel="nullChannel">
		<int:filter expression="@spelBridge.valid(payload)"
			discard-channel="invalidAdsChannel" />

		<!-- dispatch here -->
	</int:chain>

	<int:channel id="logChannel">
		<int:queue capacity="2000" />
	</int:channel>

	<int:chain input-channel="logChannel" output-channel="nullChannel">
		<int:poller receive-timeout="500" fixed-rate="1000" />
		<int:service-activator ref="logActivator"
			method="logMessage" />
	</int:chain>

	<!--int:aggregator id=""myAggregator" auto-startup="false" input-channel="aggretationChannel" 
		output-channel="outputChannel" discard-channel="nullChannel" correlation-strategy-expression="headers['urlId']" 
		12 release-strategy-expression="size() == 5" (17) expire-groups-upon-completion="false" 
		(18) empty-group-min-timeout="60000" (19) > </aggregator -->
</beans>