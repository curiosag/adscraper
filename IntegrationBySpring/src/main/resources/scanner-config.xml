<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:int="http://www.springframework.org/schema/integration"
	xmlns:int-stream="http://www.springframework.org/schema/integration/stream"
	xmlns:int-event="http://www.springframework.org/schema/integration/event"
	xmlns:int-http="http://www.springframework.org/schema/integration/http"
	xmlns:int-ws="http://www.springframework.org/schema/integration/ws"
	xmlns:task="http://www.springframework.org/schema/task"
	xmlns:int-mongodb="http://www.springframework.org/schema/integration/mongodb"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/oxm http://www.springframework.org/schema/oxm/spring-oxm.xsd
		http://www.springframework.org/schema/integration/stream http://www.springframework.org/schema/integration/stream/spring-integration-stream-4.3.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
		http://www.springframework.org/schema/integration/event http://www.springframework.org/schema/integration/event/spring-integration-event.xsd
		http://www.springframework.org/schema/integration/http http://www.springframework.org/schema/integration/http/spring-integration-http-4.3.xsd
		http://www.springframework.org/schema/integration/mail http://www.springframework.org/schema/integration/mail/spring-integration-mail.xsd
		http://www.springframework.org/schema/integration http://www.springframework.org/schema/integration/spring-integration-4.3.xsd
		http://www.springframework.org/schema/integration/ws http://www.springframework.org/schema/integration/ws/spring-integration-ws.xsd
		http://www.springframework.org/schema/task http://www.springframework.org/task/spring-task.xsd
		http://www.springframework.org/schema/integration/mongodb http://www.springframework.org/schema/integration/mongodb/spring-integration-mongodb.xsd
		http://www.springframework.org/schema/util		http://www.springframework.org/schema/util/spring-util.xsd">

	<context:component-scan base-package="org.cg.ads" />

	<task:executor id="executor" pool-size="5" />

	<bean id="serverStartupListener" class="org.cg.ads.integration.ServerStartupListener" />
	<bean id="siteScraperFactory" class="org.cg.scraping.SiteScraperFactory" />
	<bean id="logActivator" class="org.cg.ads.integration.LogActivator" />
	<bean id="spelBridge" class="org.cg.ads.integration.SpelBridge" />
	<bean id="nullChannel" class="org.springframework.integration.channel.NullChannel" />

	<bean id="sentinelBypassingRouter" class="org.cg.ads.integration.SentinelBypassingRouter">
		<constructor-arg index="0" value="getPageForUrlChannel" />
	</bean>
<!--
PingBackMassageHandler

	<int:router id="bypassSentinelsForHttpRequests" input-channel="getPageForUrlChannelPriorityFiltered"
	    ref="sentinelBypassingRouter" method="route"
		default-output-channel="httpErrorChannel">
	</int:router>
-->

	<int:recipient-list-router input-channel="getPageForUrlChannelPriorityFiltered">
		<int:recipient channel="getPageForUrlChannel"
			selector-expression="headers[priority] == 0" />
		<int:recipient channel="getPageForUrlChannel"
			selector-expression="headers[priority] > 0" />
	</int:recipient-list-router>


	<int:service-activator input-channel="bypassPageForUrlChannel"
		ref="logActivator" method="logMessage" />

	<int-http:outbound-gateway id="html" url="{url}"
		request-channel="getPageForUrlChannel" http-method="GET"
		expected-response-type="java.lang.String" charset="UTF-8"
		reply-timeout="20000">
		<int-http:uri-variable name="url" expression="payload" />
	</int-http:outbound-gateway>


	<!-- *** system entry *** -->
	<int:gateway default-request-channel="systemEntry"
		service-interface="org.cg.ads.SystemEntryGateway" />

	<int:chain id="waitToStartupFinishedAndSplit" input-channel="systemEntry"
		output-channel="systemEntryAfterStartup">
		<int:filter ref="serverStartupListener" discard-channel="logPrematureMessages" />
		<int:splitter expression="payload" />
		<int:header-enricher>
			<int:priority expression="payload.toString().contains('sentinel') ? 0 : 1" />
		</int:header-enricher>
	</int:chain>

	<int:channel id="systemEntryAfterStartup">
		<int:dispatcher task-executor="executor" />
	</int:channel>

	<int:chain id="scrapeMasterList" input-channel="systemEntryAfterStartup"
		output-channel="scrapeMasterListResultChannel">

		<int:service-activator ref="logActivator"
			method="logMessage" />

		<int:header-enricher>
			<int:header name="urlId" expression="payload.id" />
			<int:header name="baseUrl" expression="payload.url" />
		</int:header-enricher>

		<!-- actually there's no need to enrich/transform with id and url in header, 
			but it makes reuse of http gateway possible -->

		<int:transformer id="packPayloadForEnrichmentByAdMainPageHttpRequest"
			expression="new org.cg.ads.integration.PayloadEnrichmentTarget(payload)" />
		<int:enricher id="getPageForUrl" request-channel="getPageForUrlChannelPriorityFiltered"
			error-channel="httpErrorChannel" request-payload-expression="headers['baseUrl']">
			<int:property name="added" expression="payload" />
		</int:enricher>

		<!-- (String, String) -> List<ScrapedValues> -->
		<int:transformer
			expression="@spelBridge.scrapeMasterList(headers['baseUrl'], payload.added)" />

		<int:splitter expression="payload" />
	</int:chain>

	<int:channel id="scrapeMasterListResultChannel">
		<int:dispatcher task-executor="executor" />
	</int:channel>

	<int:chain id="scrapeDetails" input-channel="scrapeMasterListResultChannel"
		output-channel="scrapeResultChannel">

		<int:header-enricher>
			<int:header name="detailUrl"
				expression="payload.has(T(org.cg.ads.advalues.ValueKind).url) ? payload.valueOrDefault(T(org.cg.ads.advalues.ValueKind).url) : '' " />
		</int:header-enricher>

		<int:service-activator ref="logActivator"
			method="logMessage" />

		<int:filter id="filterForDetailUrlPresent" expression="! headers['detailUrl'].equals('')" />
		<int:filter id="filterForUrlsNotYetScraped"
			expression="! T(org.cg.history.History).instance().find(headers['urlId'], headers['detailUrl'])" />

		<int:transformer id="packPayloadForEnrichmentByAdDetailPageHttpRequest"
			expression="new org.cg.ads.integration.PayloadEnrichmentTarget(payload)" />
		<int:enricher id="getPageForDetailUrl" request-channel="getPageForUrlChannelPriorityFiltered"
			error-channel="httpErrorChannel" request-payload-expression="headers['detailUrl']">
			<int:property name="added" expression="payload" />
		</int:enricher>

		<!-- (ScrapedValues, String) -> ScrapedValues (with more properties) -->
		<int:transformer
			expression="@spelBridge.scrapeDetails(headers['detailUrl'], payload.base, payload.added)" />
	</int:chain>

	<int:publish-subscribe-channel id="scrapeResultChannel"
		apply-sequence="true" ignore-failures="true" />

	<int:bridge input-channel="scrapeResultChannel"
		output-channel="scrapeResultSyncChannel" />
	<int:channel id="scrapeResultSyncChannel">
		<int:queue capacity="200" />
	</int:channel>

	<int:chain input-channel="scrapeResultSyncChannel">
		<int:poller receive-timeout="500" fixed-rate="20000" />
		<int:transformer
			expression="'result - thread '.concat(T(Thread).currentThread().id).concat(' ') + payload.toString()" />
		<int-stream:stdout-channel-adapter
			id="consoleOut" append-newline="true" />
	</int:chain>

	<int:transformer input-channel="httpErrorChannel"
		output-channel="logChannel" expression="'httpError:' + payload.toString()" />

	<int:transformer input-channel="invalidAdsChannel"
		output-channel="logChannel" expression="'discarded invalid ad: '.concat(headers['detailUrl'])" />

	<int:transformer input-channel="logPrematureMessages"
		output-channel="logChannel"
		expression="'didnt wait for server to start, discarded: ' + payload.toString()" />

	<int:service-activator input-channel="scrapeResultChannel"
		output-channel="nullChannel" id="storeInHistory" ref="spelBridge"
		method="historyStorage" />


	<int:chain input-channel="scrapeResultChannel"
		output-channel="nullChannel">
		<int:filter expression="@spelBridge.valid(payload)"
			discard-channel="invalidAdsChannel" />

		<!-- dispatch here -->
	</int:chain>

	<int:channel id="logChannel">
		<int:queue capacity="2000" />
	</int:channel>

	<int:chain input-channel="logChannel" output-channel="nullChannel">
		<int:poller receive-timeout="500" fixed-rate="1000" />
		<int:service-activator ref="logActivator"
			method="logMessage" />
	</int:chain>

</beans>